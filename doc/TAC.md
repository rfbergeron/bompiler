# Three-address code definition

## Keyword list
- `sizeof`
- `temp`
- `param`
- `call`
- `ret`
- `label`

## Other potential keywords
- `neg` (ambiguity between the unary and binary minus)
- `prom`/`promote`/`pos` (ambiguity between the unary and binary plus)
- `addrof` (ambiguity between bitwise "and" and the address-of operator)
- `deref` (not necessary if we use parentheses instead)
- `let` (only necessary if we want to include type information)
- `const` (an alias for what would be compile-time constants, for readability)

## Syntax
```
number: [0-9]+
ident: [a-zA-Z][a-zA-Z0-9_-]*
temporary value: "temp" number
parameter value: "param" number
memory access: '(' (ident | temporary value) ',' number ',' (ident | temporary value) ',' number ')'
subroutine call: "call" ident
goto statement: "goto" ident
label declaration: "label" ident
return statement: "ret" | ret ident | ret temporary value
operand: number | ident | temporary value | memory access
unary expression: operand '=' operator operand
binary expression: operand '=' operand operator operand
assignment expression: operand '=' operand
```

## Unknowable values
The value of some expressions will not be known until the three-address code is
translated to assembly, like the result of the `sizeof` operator. These values
will be copied into the generated code verbatim. In the case of the `sizeof`
operator, `sizeof` will also be an operator and keyword in our three-address
code.

## Unary and binary operator ambiguity
Some symbols are overloaded and may be either a unary or binary operator,
depending on the number of arguments that are provided to them. We could reduce
ambiguity by using keywords for the unary versions of the operators.

## Temporary variables
To prevent interfering with names generated by the compiler, temporary and
intermediate values in a complex computation will be defined and referred to
using the syntax `temp n`. For example, in three-address code, the expression
`a = b + c * d` would look like:

```
temp 0 = c * d
a = b + temp 0
```

Temporaries are numbered in ascending order, starting from 0. The count is reset
at the end of a function body.

## Function calls and their parameters
For the same reasons that temporary variables are declared the way they are,
parameters to a function call are declared with the syntax `param n`. A call
to a function `int add(int a, int b, int c)` would look like:

```
param 0 = someVar
param 1 = anotherVar
param 2 = yetAnotherVar
call add
```

Parameters are numbered in ascending order, starting from 0. The count is reset
every time a `call` statement is emitted.

## Returning from a function
At the end of each function, there must be at least one `ret`. `ret` has an
optional parameter, which may be a temporary, an identifier, an arithmetic
constant, or a pointer constant. `ret` statements may also occur at any other
point within the function.

## Scaled-index loads and stores
amd64 and arm64 support loading and storing and indexing with a single op,
albeit in very different ways. RISC-V does not. Optimizing indexed loads and
stores into code that has lost that information sounds more difficult than
generating extra assembly for architectures that do not have this feature, so
this three-address code will also have syntax for offset and scaled index
loads and stores. It will take the form `(val, offset, val, scale)`; `val` can
be a temporary or an identifier; `scale` can be the `sizeof` operator or an
integer constant with the value 1, 2, 4 or 8; offset can be an integer constant
or the `sizeof` operator, or a summation of integer constants and `sizeof`
operators.

All fields except for the first are optional. The `offset` and `scale` fields
can be safely omitted; if they are, their values are taken to be `0` and `1`,
respectively. You may not specify the `scale` field if the second `val` field
is not specified; if there are three fields, the third must be a temporary or
an identifier.

This scheme allows us to represent indirection, struct member access, and
array indexing in a unified way.

This is very much not like standard three-address code. However, it would be
easy to turn off the generation of scaled-index loads and stores. Instead,
the compiler would use the `*` or `deref` operator to indicate memory access,
and the offset and index math would be done before dereferencing the pointer.

## Flow control
All selection, iteration, and jump statements except for `return` statements are
translated to simple, one line if statements.

## If
All if statements must have the form `if val op val goto ident`; `val` can be a
temporary, an identifier, or an integer constant; `op` can be any relational or
comparison operator, and `ident` can be the name of any label defined within the
function body the if statement is located in.

## Goto
Goto statements take the form `goto ident`, where `ident` is the name of any
label defined within the function body that the goto statement is located in.
